'From Pharo0.1 of 16 May 2008 [Latest update: #10204] on 29 January 2010 at 12:26:23 am'!!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index bigEndian: bool 	"Return a 64 bit float starting from the given byte index"	| w1 w2 dbl |	w1 := self unsignedLongAt: index bigEndian: bool.	w2 := self unsignedLongAt: index + 4 bigEndian: bool.	dbl := Float new: 2. 	bool		ifTrue: [dbl basicAt: 1 put: w1.			dbl basicAt: 2 put: w2]		ifFalse: [dbl basicAt: 1 put: w2.			dbl basicAt: 2 put: w1].	^ dbl! !!ByteArray methodsFor: 'platform independent access' stamp: 'jmb 12/3/2004 14:54'!doubleAt: index put: value bigEndian: bool 	"Store a 64 bit float starting from the given byte index"	| w1 w2 |	bool		ifTrue: [w1 := value basicAt: 1.			w2 := value basicAt: 2]		ifFalse: [w1 := value basicAt: 2.			w2 := value basicAt: 1]. 	self unsignedLongAt: index put: w1 bigEndian: bool.	self unsignedLongAt: index + 4 put: w2 bigEndian: bool.	^ value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:44'!longAt: index bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 w h |	aBool ifTrue:[		b0 := self at: index.		b1 := self at: index+1.		b2 := self at: index+2.		w := self at: index+3.	] ifFalse:[		w := self at: index.		b2 := self at: index+1.		b1 := self at: index+2.		b0 := self at: index+3.	].	"Minimize LargeInteger arithmetic"	h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].	h = 0 ifFalse:[w := (h bitShift: 16) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 8/2/2003 19:29'!longAt: index put: value bigEndian: aBool	"Return a 32bit integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 := value bitShift: -24.	b0 := (b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80).	b0 < 0 ifTrue:[b0 := 256 + b0].	b1 := (value bitShift: -16) bitAnd: 255.	b2 := (value bitShift: -8) bitAnd: 255.	b3 := value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:57'!shortAt: index bigEndian: aBool	"Return a 16 bit integer quantity starting from the given byte index"	| uShort |	uShort := self unsignedShortAt: index bigEndian: aBool.	^(uShort bitAnd: 16r7FFF) - (uShort bitAnd: 16r8000)! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/3/1998 14:20'!shortAt: index put: value bigEndian: aBool	"Store a 16 bit integer quantity starting from the given byte index"	self unsignedShortAt: index put: (value bitAnd: 16r7FFF) - (value bitAnd: -16r8000) bigEndian: aBool.	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index bigEndian: aBool	"Return a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 w |	aBool ifTrue:[		b0 := self at: index.		b1 := self at: index+1.		b2 := self at: index+2.		w := self at: index+3.	] ifFalse:[		w := self at: index.		b2 := self at: index+1.		b1 := self at: index+2.		b0 := self at: index+3.	].	"Minimize LargeInteger arithmetic"	b2 = 0 ifFalse:[w := (b2 bitShift: 8) + w].	b1 = 0 ifFalse:[w := (b1 bitShift: 16) + w].	b0 = 0 ifFalse:[w := (b0 bitShift: 24) + w].	^w! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:49'!unsignedLongAt: index put: value bigEndian: aBool	"Store a 32bit unsigned integer quantity starting from the given byte index"	| b0 b1 b2 b3 |	b0 := value bitShift: -24.	b1 := (value bitShift: -16) bitAnd: 255.	b2 := (value bitShift: -8) bitAnd: 255.	b3 := value bitAnd: 255.	aBool ifTrue:[		self at: index put: b0.		self at: index+1 put: b1.		self at: index+2 put: b2.		self at: index+3 put: b3.	] ifFalse:[		self at: index put: b3.		self at: index+1 put: b2.		self at: index+2 put: b1.		self at: index+3 put: b0.	].	^value! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:51'!unsignedShortAt: index bigEndian: aBool	"Return a 16 bit unsigned integer quantity starting from the given byte index"	^aBool 		ifTrue:[((self at: index) bitShift: 8) + (self at: index+1)]		ifFalse:[((self at: index+1) bitShift: 8) + (self at: index)].! !!ByteArray methodsFor: 'platform independent access' stamp: 'ar 11/1/1998 20:53'!unsignedShortAt: index put: value bigEndian: aBool	"Store a 16 bit unsigned integer quantity starting from the given byte index"	aBool ifTrue:[		self at: index put: (value bitShift: -8).		self at: index+1 put: (value bitAnd: 255).	] ifFalse:[		self at: index+1 put: (value bitShift: -8).		self at: index put: (value bitAnd: 255).	].	^value! !